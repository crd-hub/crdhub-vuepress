<h3 id="distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitch">VirtualSwitch
</h3>
<div>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>apiVersion</code><br/>
string</td>
<td>
<code>
distributed.vsphere.kubeform.com/v1alpha1
</code>
</td>
</tr>
<tr>
<td>
<code>kind</code><br/>
string
</td>
<td><code>VirtualSwitch</code></td>
</tr>
<tr>
<td>
<code>metadata</code><br/>
<em>
<a href="https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#objectmeta-v1-meta">
Kubernetes meta/v1.ObjectMeta
</a>
</em>
</td>
<td>
Refer to the Kubernetes API documentation for the fields of the
<code>metadata</code> field.
</td>
</tr>
<tr>
<td>
<code>spec</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpec">
VirtualSwitchSpec
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>state</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">
VirtualSwitchSpecResource
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>resource</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">
VirtualSwitchSpecResource
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>updatePolicy</code><br/>
<em>
kubeform.dev/apimachinery/api/v1alpha1.UpdatePolicy
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>terminationPolicy</code><br/>
<em>
kubeform.dev/apimachinery/api/v1alpha1.TerminationPolicy
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>providerRef</code><br/>
<em>
<a href="https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#localobjectreference-v1-core">
Kubernetes core/v1.LocalObjectReference
</a>
</em>
</td>
<td>
</td>
</tr>
</table>
</td>
</tr>
<tr>
<td>
<code>status</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchStatus">
VirtualSwitchStatus
</a>
</em>
</td>
<td>
<br/>
<br/>
<table>
<tr>
<td>
<code>observedGeneration</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Resource generation, which is updated on mutation by the API Server.</p>
</td>
</tr>
<tr>
<td>
<code>phase</code><br/>
<em>
sigs.k8s.io/cli-utils/pkg/kstatus/status.Status
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>conditions</code><br/>
<em>
[]kmodules.xyz/client-go/api/v1.Condition
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</table>
</td>
</tr>
</tbody>
</table>
<h3 id="distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpec">VirtualSwitchSpec
</h3>
<p>
(<em>Appears on:</em><a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitch">VirtualSwitch</a>)
</p>
<div>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>state</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">
VirtualSwitchSpecResource
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>resource</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">
VirtualSwitchSpecResource
</a>
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>updatePolicy</code><br/>
<em>
kubeform.dev/apimachinery/api/v1alpha1.UpdatePolicy
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>terminationPolicy</code><br/>
<em>
kubeform.dev/apimachinery/api/v1alpha1.TerminationPolicy
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>providerRef</code><br/>
<em>
<a href="https://v1-21.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.21/#localobjectreference-v1-core">
Kubernetes core/v1.LocalObjectReference
</a>
</em>
</td>
<td>
</td>
</tr>
</tbody>
</table>
<h3 id="distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecHost">VirtualSwitchSpecHost
</h3>
<p>
(<em>Appears on:</em><a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">VirtualSwitchSpecResource</a>)
</p>
<div>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>devices</code><br/>
<em>
[]string
</em>
</td>
<td>
<p>Name of the physical NIC to be added to the proxy switch.</p>
</td>
</tr>
<tr>
<td>
<code>hostSystemID</code><br/>
<em>
string
</em>
</td>
<td>
<p>The managed object ID of the host this specification applies to.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecPvlanMapping">VirtualSwitchSpecPvlanMapping
</h3>
<p>
(<em>Appears on:</em><a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">VirtualSwitchSpecResource</a>)
</p>
<div>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>primaryVLANID</code><br/>
<em>
int64
</em>
</td>
<td>
<p>The primary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.</p>
</td>
</tr>
<tr>
<td>
<code>pvlanType</code><br/>
<em>
string
</em>
</td>
<td>
<p>The private VLAN type. Valid values are promiscuous, community and isolated.</p>
</td>
</tr>
<tr>
<td>
<code>secondaryVLANID</code><br/>
<em>
int64
</em>
</td>
<td>
<p>The secondary VLAN ID. The VLAN IDs of 0 and 4095 are reserved and cannot be used in this property.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">VirtualSwitchSpecResource
</h3>
<p>
(<em>Appears on:</em><a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpec">VirtualSwitchSpec</a>)
</p>
<div>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>id</code><br/>
<em>
string
</em>
</td>
<td>
</td>
</tr>
<tr>
<td>
<code>activeUplinks</code><br/>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>List of active uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.</p>
</td>
</tr>
<tr>
<td>
<code>allowForgedTransmits</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Controls whether or not the virtual network adapter is allowed to send network traffic with a different MAC address than that of its own.</p>
</td>
</tr>
<tr>
<td>
<code>allowMACChanges</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Controls whether or not the Media Access Control (MAC) address can be changed.</p>
</td>
</tr>
<tr>
<td>
<code>allowPromiscuous</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Enable promiscuous mode on the network. This flag indicates whether or not all traffic is seen on a given port.</p>
</td>
</tr>
<tr>
<td>
<code>backupnfcMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the backupNfc traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>backupnfcReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the backupNfc traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>backupnfcShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the backupNfc traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>backupnfcShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the backupNfc traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>blockAllPorts</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Indicates whether to block all ports by default.</p>
</td>
</tr>
<tr>
<td>
<code>checkBeacon</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Enable beacon probing on the ports this policy applies to.</p>
</td>
</tr>
<tr>
<td>
<code>configVersion</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The version string of the configuration that this spec is trying to change.</p>
</td>
</tr>
<tr>
<td>
<code>contactDetail</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The contact detail for this DVS.</p>
</td>
</tr>
<tr>
<td>
<code>contactName</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The contact name for this DVS.</p>
</td>
</tr>
<tr>
<td>
<code>customAttributes</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>A list of custom attributes to set on this resource.</p>
</td>
</tr>
<tr>
<td>
<code>datacenterID</code><br/>
<em>
string
</em>
</td>
<td>
<p>The ID of the datacenter to create this virtual switch in.</p>
</td>
</tr>
<tr>
<td>
<code>description</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The description of the DVS.</p>
</td>
</tr>
<tr>
<td>
<code>directpathGen2Allowed</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Allow VMDirectPath Gen2 on the ports this policy applies to.</p>
</td>
</tr>
<tr>
<td>
<code>egressShapingAverageBandwidth</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The average egress bandwidth in bits per second if egress shaping is enabled on the port.</p>
</td>
</tr>
<tr>
<td>
<code>egressShapingBurstSize</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum egress burst size allowed in bytes if egress shaping is enabled on the port.</p>
</td>
</tr>
<tr>
<td>
<code>egressShapingEnabled</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>True if the traffic shaper is enabled for egress traffic on the port.</p>
</td>
</tr>
<tr>
<td>
<code>egressShapingPeakBandwidth</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The peak egress bandwidth during bursts in bits per second if egress traffic shaping is enabled on the port.</p>
</td>
</tr>
<tr>
<td>
<code>failback</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>If true, the teaming policy will re-activate failed interfaces higher in precedence when they come back up.</p>
</td>
</tr>
<tr>
<td>
<code>faulttoleranceMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the faultTolerance traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>faulttoleranceReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the faultTolerance traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>faulttoleranceShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the faultTolerance traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>faulttoleranceShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the faultTolerance traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>folder</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The folder to create this virtual switch in, relative to the datacenter.</p>
</td>
</tr>
<tr>
<td>
<code>hbrMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the hbr traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>hbrReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the hbr traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>hbrShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the hbr traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>hbrShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the hbr traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>host</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecHost">
[]VirtualSwitchSpecHost
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>A host member specification.</p>
</td>
</tr>
<tr>
<td>
<code>ignoreOtherPvlanMappings</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Whether to ignore existing PVLAN mappings not managed by this resource. Defaults to false.</p>
</td>
</tr>
<tr>
<td>
<code>ingressShapingAverageBandwidth</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The average ingress bandwidth in bits per second if ingress shaping is enabled on the port.</p>
</td>
</tr>
<tr>
<td>
<code>ingressShapingBurstSize</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum ingress burst size allowed in bytes if ingress shaping is enabled on the port.</p>
</td>
</tr>
<tr>
<td>
<code>ingressShapingEnabled</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>True if the traffic shaper is enabled for ingress traffic on the port.</p>
</td>
</tr>
<tr>
<td>
<code>ingressShapingPeakBandwidth</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The peak ingress bandwidth during bursts in bits per second if ingress traffic shaping is enabled on the port.</p>
</td>
</tr>
<tr>
<td>
<code>ipv4Address</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The IPv4 address of the switch. This can be used to see the DVS as a unique device with NetFlow.</p>
</td>
</tr>
<tr>
<td>
<code>iscsiMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the iSCSI traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>iscsiReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the iSCSI traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>iscsiShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the iSCSI traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>iscsiShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the iSCSI traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>lacpAPIVersion</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The Link Aggregation Control Protocol group version in the switch. Can be one of singleLag or multipleLag.</p>
</td>
</tr>
<tr>
<td>
<code>lacpEnabled</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Whether or not to enable LACP on all uplink ports.</p>
</td>
</tr>
<tr>
<td>
<code>lacpMode</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The uplink LACP mode to use. Can be one of active or passive.</p>
</td>
</tr>
<tr>
<td>
<code>linkDiscoveryOperation</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>Whether to advertise or listen for link discovery. Valid values are advertise, both, listen, and none.</p>
</td>
</tr>
<tr>
<td>
<code>linkDiscoveryProtocol</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The discovery protocol type. Valid values are cdp and lldp.</p>
</td>
</tr>
<tr>
<td>
<code>managementMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the management traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>managementReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the management traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>managementShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the management traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>managementShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the management traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>maxMTU</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum MTU on the switch.</p>
</td>
</tr>
<tr>
<td>
<code>multicastFilteringMode</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The multicast filtering mode on the switch. Can be one of legacyFiltering, or snooping.</p>
</td>
</tr>
<tr>
<td>
<code>name</code><br/>
<em>
string
</em>
</td>
<td>
<p>The name for the DVS. Must be unique in the folder that it is being created in.</p>
</td>
</tr>
<tr>
<td>
<code>netflowActiveFlowTimeout</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The number of seconds after which active flows are forced to be exported to the collector.</p>
</td>
</tr>
<tr>
<td>
<code>netflowCollectorIPAddress</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>IP address for the netflow collector, using IPv4 or IPv6. IPv6 is supported in vSphere Distributed Switch Version 6.0 or later.</p>
</td>
</tr>
<tr>
<td>
<code>netflowCollectorPort</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The port for the netflow collector.</p>
</td>
</tr>
<tr>
<td>
<code>netflowEnabled</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Indicates whether to enable netflow on all ports.</p>
</td>
</tr>
<tr>
<td>
<code>netflowIdleFlowTimeout</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The number of seconds after which idle flows are forced to be exported to the collector.</p>
</td>
</tr>
<tr>
<td>
<code>netflowInternalFlowsOnly</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Whether to limit analysis to traffic that has both source and destination served by the same host.</p>
</td>
</tr>
<tr>
<td>
<code>netflowObservationDomainID</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The observation Domain ID for the netflow collector.</p>
</td>
</tr>
<tr>
<td>
<code>netflowSamplingRate</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The ratio of total number of packets to the number of packets analyzed. Set to 0 to disable sampling, meaning that all packets are analyzed.</p>
</td>
</tr>
<tr>
<td>
<code>networkResourceControlEnabled</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>Whether or not to enable network resource control, enabling advanced traffic shaping and resource control features.</p>
</td>
</tr>
<tr>
<td>
<code>networkResourceControlVersion</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The network I/O control version to use. Can be one of version2 or version3.</p>
</td>
</tr>
<tr>
<td>
<code>nfsMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the nfs traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>nfsReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the nfs traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>nfsShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the nfs traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>nfsShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the nfs traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>notifySwitches</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>If true, the teaming policy will notify the broadcast network of a NIC failover, triggering cache updates.</p>
</td>
</tr>
<tr>
<td>
<code>portPrivateSecondaryVLANID</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The secondary VLAN ID for this port.</p>
</td>
</tr>
<tr>
<td>
<code>pvlanMapping</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecPvlanMapping">
[]VirtualSwitchSpecPvlanMapping
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>A private VLAN (PVLAN) mapping.</p>
</td>
</tr>
<tr>
<td>
<code>standbyUplinks</code><br/>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>List of standby uplinks used for load balancing, matching the names of the uplinks assigned in the DVS.</p>
</td>
</tr>
<tr>
<td>
<code>tags</code><br/>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>A list of tag IDs to apply to this object.</p>
</td>
</tr>
<tr>
<td>
<code>teamingPolicy</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The network adapter teaming policy. Can be one of loadbalance_ip, loadbalance_srcmac, loadbalance_srcid, failover_explicit, or loadbalance_loadbased.</p>
</td>
</tr>
<tr>
<td>
<code>txUplink</code><br/>
<em>
bool
</em>
</td>
<td>
<em>(Optional)</em>
<p>If true, a copy of packets sent to the switch will always be forwarded to an uplink in addition to the regular packet forwarded done by the switch.</p>
</td>
</tr>
<tr>
<td>
<code>uplinks</code><br/>
<em>
[]string
</em>
</td>
<td>
<em>(Optional)</em>
<p>A list of uplink ports. The contents of this list control both the uplink count and names of the uplinks on the DVS across hosts.</p>
</td>
</tr>
<tr>
<td>
<code>vdpMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the vdp traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>vdpReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the vdp traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>vdpShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the vdp traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>vdpShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the vdp traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>version</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The version of this virtual switch. Allowed versions are 7.0.0, 6.5.0, 6.0.0, 5.5.0, 5.1.0, and 5.0.0.</p>
</td>
</tr>
<tr>
<td>
<code>virtualmachineMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the virtualMachine traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>virtualmachineReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the virtualMachine traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>virtualmachineShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the virtualMachine traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>virtualmachineShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the virtualMachine traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>vlanID</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The VLAN ID for single VLAN mode. 0 denotes no VLAN.</p>
</td>
</tr>
<tr>
<td>
<code>vlanRange</code><br/>
<em>
<a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecVlanRange">
[]VirtualSwitchSpecVlanRange
</a>
</em>
</td>
<td>
<em>(Optional)</em>
<p>The VLAN ID for single VLAN mode. 0 denotes no VLAN.</p>
</td>
</tr>
<tr>
<td>
<code>vmotionMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the vmotion traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>vmotionReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the vmotion traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>vmotionShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the vmotion traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>vmotionShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the vmotion traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
<tr>
<td>
<code>vsanMaximumMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The maximum allowed usage for the vsan traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>vsanReservationMbit</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of guaranteed bandwidth for the vsan traffic class, in Mbits/sec.</p>
</td>
</tr>
<tr>
<td>
<code>vsanShareCount</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>The amount of shares to allocate to the vsan traffic class for a custom share level.</p>
</td>
</tr>
<tr>
<td>
<code>vsanShareLevel</code><br/>
<em>
string
</em>
</td>
<td>
<em>(Optional)</em>
<p>The allocation level for the vsan traffic class. Can be one of high, low, normal, or custom.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecVlanRange">VirtualSwitchSpecVlanRange
</h3>
<p>
(<em>Appears on:</em><a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchSpecResource">VirtualSwitchSpecResource</a>)
</p>
<div>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>maxVLAN</code><br/>
<em>
int64
</em>
</td>
<td>
<p>The minimum VLAN to use in the range.</p>
</td>
</tr>
<tr>
<td>
<code>minVLAN</code><br/>
<em>
int64
</em>
</td>
<td>
<p>The minimum VLAN to use in the range.</p>
</td>
</tr>
</tbody>
</table>
<h3 id="distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitchStatus">VirtualSwitchStatus
</h3>
<p>
(<em>Appears on:</em><a href="#distributed.vsphere.kubeform.com/v1alpha1.VirtualSwitch">VirtualSwitch</a>)
</p>
<div>
</div>
<table>
<thead>
<tr>
<th>Field</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>
<code>observedGeneration</code><br/>
<em>
int64
</em>
</td>
<td>
<em>(Optional)</em>
<p>Resource generation, which is updated on mutation by the API Server.</p>
</td>
</tr>
<tr>
<td>
<code>phase</code><br/>
<em>
sigs.k8s.io/cli-utils/pkg/kstatus/status.Status
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
<tr>
<td>
<code>conditions</code><br/>
<em>
[]kmodules.xyz/client-go/api/v1.Condition
</em>
</td>
<td>
<em>(Optional)</em>
</td>
</tr>
</tbody>
</table>
<p><em>
Generated with <code>gen-api-reference-docs</code>
on git commit <code>d8371ee</code>.
</em></p>
